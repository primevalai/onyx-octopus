#!/usr/bin/env python3
"""
Example 28: Vulnerability Scanning and Security Assessment

This example demonstrates how to:
1. Scan events for security vulnerabilities
2. Detect common attack patterns (SQL injection, XSS, etc.)
3. Classify vulnerabilities by severity and category
4. Generate security reports and compliance scores
5. Implement whitelisting and false positive management
6. Provide remediation guidance

Run with: uv run python examples/28_vulnerability_scanning.py
"""

import asyncio
import json
import re
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from uuid import uuid4
from enum import Enum

# Mock implementation demonstrating vulnerability scanning API
class VulnerabilityCategory(Enum):
    DATA_LEAKAGE = "DataLeakage"
    INJECTION_ATTACK = "InjectionAttack"
    ACCESS_CONTROL = "AccessControl"
    CRYPTOGRAPHIC = "Cryptographic"
    AUTHENTICATION = "Authentication"
    AUTHORIZATION = "Authorization"
    INPUT_VALIDATION = "InputValidation"
    OUTPUT_ENCODING = "OutputEncoding"
    SESSION_MANAGEMENT = "SessionManagement"
    ERROR_HANDLING = "ErrorHandling"
    LOGGING = "Logging"
    CONFIGURATION = "Configuration"
    BUSINESS_LOGIC = "BusinessLogic"
    API_SECURITY = "ApiSecurity"
    NETWORK_SECURITY = "NetworkSecurity"

class VulnerabilitySeverity(Enum):
    CRITICAL = "Critical"
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"
    INFO = "Info"

class VulnerabilityStatus(Enum):
    OPEN = "Open"
    IN_PROGRESS = "InProgress"
    RESOLVED = "Resolved"
    FALSE_POSITIVE = "FalsePositive"
    ACCEPTED = "Accepted"
    SUPPRESSED = "Suppressed"

class MockVulnerabilityScanner:
    """Mock implementation of vulnerability scanning"""
    
    def __init__(self):
        self.scan_rules = []
        self.whitelist = set()
        self.severity_thresholds = {
            VulnerabilitySeverity.CRITICAL: 0,
            VulnerabilitySeverity.HIGH: 5,
            VulnerabilitySeverity.MEDIUM: 20,
            VulnerabilitySeverity.LOW: 50,
            VulnerabilitySeverity.INFO: 100
        }
        self._load_default_rules()
    
    def _load_default_rules(self):
        """Load default vulnerability scanning rules"""
        self.scan_rules = [
            {
                "id": "sql-injection-001",
                "name": "SQL Injection Pattern Detection",
                "description": "Detects potential SQL injection patterns in event data",
                "category": VulnerabilityCategory.INJECTION_ATTACK,
                "severity": VulnerabilitySeverity.HIGH,
                "pattern_type": "regex",
                "pattern": r"(?i)(union\s+select|select\s+.*\s+from|insert\s+into|update\s+.*\s+set|delete\s+from|drop\s+table|\'\s*or\s*\'\w*\'\s*=\s*\'\w*|admin\'\s*--|\'\s*;\s*drop)",
                "enabled": True
            },
            {
                "id": "pii-exposure-001", 
                "name": "PII Data Exposure",
                "description": "Detects potential exposure of personally identifiable information",
                "category": VulnerabilityCategory.DATA_LEAKAGE,
                "severity": VulnerabilitySeverity.CRITICAL,
                "pattern_type": "keywords",
                "pattern": ["ssn", "social_security", "credit_card", "passport", "driver_license"],
                "enabled": True
            },
            {
                "id": "auth-weakness-001",
                "name": "Weak Authentication Patterns", 
                "description": "Detects weak authentication patterns",
                "category": VulnerabilityCategory.AUTHENTICATION,
                "severity": VulnerabilitySeverity.MEDIUM,
                "pattern_type": "keywords", 
                "pattern": ["password=123456", "password=admin", "password=password", "admin:admin", "guest:guest"],
                "enabled": True
            },
            {
                "id": "xss-001",
                "name": "Cross-Site Scripting (XSS)",
                "description": "Detects potential XSS payloads in event data",
                "category": VulnerabilityCategory.INPUT_VALIDATION,
                "severity": VulnerabilitySeverity.HIGH,
                "pattern_type": "regex",
                "pattern": r"(?i)(<script|javascript:|onclick|onload|onerror|onmouseover|alert\(|confirm\(|prompt\()",
                "enabled": True
            },
            {
                "id": "sensitive-paths-001",
                "name": "Sensitive Path Disclosure",
                "description": "Detects exposure of sensitive system paths",
                "category": VulnerabilityCategory.CONFIGURATION,
                "severity": VulnerabilitySeverity.MEDIUM,
                "pattern_type": "keywords",
                "pattern": ["/etc/passwd", "/etc/shadow", "C:\\Windows\\System32", "/.env", "/proc/", "web.config"],
                "enabled": True
            },
            {
                "id": "api-key-exposure-001",
                "name": "API Key Exposure",
                "description": "Detects potential API key or secret exposure",
                "category": VulnerabilityCategory.CRYPTOGRAPHIC,
                "severity": VulnerabilitySeverity.CRITICAL,
                "pattern_type": "regex",
                "pattern": r"(?i)(api[_-]?key|secret[_-]?key|access[_-]?token|auth[_-]?token)[\"'\s]*[:=][\"'\s]*[a-zA-Z0-9]{20,}",
                "enabled": True
            }
        ]
    
    def add_to_whitelist(self, aggregate_id: str):
        """Add aggregate to vulnerability scanning whitelist"""
        self.whitelist.add(aggregate_id)
    
    def remove_from_whitelist(self, aggregate_id: str):
        """Remove aggregate from whitelist"""
        self.whitelist.discard(aggregate_id)
    
    async def scan_events(self, events: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Scan events for security vulnerabilities"""
        scan_start = datetime.utcnow()
        scan_id = str(uuid4())
        
        vulnerabilities = []
        severity_counts = {severity: 0 for severity in VulnerabilitySeverity}
        category_counts = {category: 0 for category in VulnerabilityCategory}
        
        for event in events:
            # Skip whitelisted aggregates
            if event["aggregate_id"] in self.whitelist:
                continue
            
            for rule in self.scan_rules:
                if not rule["enabled"]:
                    continue
                
                finding = await self._apply_scan_rule(event, rule)
                if finding:
                    vulnerabilities.append(finding)
                    severity_counts[finding["severity"]] += 1
                    category_counts[finding["category"]] += 1
        
        scan_end = datetime.utcnow()
        scan_duration = (scan_end - scan_start).total_seconds() * 1000
        
        compliance_score = self._calculate_compliance_score(severity_counts, len(events))
        
        return {
            "scan_id": scan_id,
            "scan_timestamp": scan_start,
            "events_scanned": len(events),
            "vulnerabilities_found": vulnerabilities,
            "scan_duration_ms": scan_duration,
            "severity_counts": {k.value: v for k, v in severity_counts.items()},
            "category_counts": {k.value: v for k, v in category_counts.items()},
            "compliance_score": compliance_score
        }
    
    async def _apply_scan_rule(self, event: Dict[str, Any], rule: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Apply a single scan rule to an event"""
        # Convert event data to string for scanning
        event_data_str = json.dumps(event.get("data", {})).lower()
        
        # Apply pattern matching based on rule type
        matches = False
        evidence = ""
        
        if rule["pattern_type"] == "regex":
            pattern = re.compile(rule["pattern"])
            match = pattern.search(event_data_str)
            if match:
                matches = True
                evidence = f"Matched pattern: {match.group()}"
        
        elif rule["pattern_type"] == "keywords":
            for keyword in rule["pattern"]:
                if keyword.lower() in event_data_str:
                    matches = True
                    evidence = f"Found keyword: {keyword}"
                    break
        
        if matches:
            return {
                "id": str(uuid4()),
                "rule_id": rule["id"],
                "event_id": event["id"],
                "aggregate_id": event["aggregate_id"],
                "category": rule["category"],
                "severity": rule["severity"],
                "title": rule["name"],
                "description": rule["description"],
                "evidence": evidence,
                "remediation": self._get_remediation_advice(rule["category"]),
                "owasp_references": self._get_owasp_references(rule["category"]),
                "found_at": datetime.utcnow(),
                "status": VulnerabilityStatus.OPEN
            }
        
        return None
    
    def _get_remediation_advice(self, category: VulnerabilityCategory) -> str:
        """Get remediation advice for vulnerability category"""
        remediation_map = {
            VulnerabilityCategory.DATA_LEAKAGE: "Remove or encrypt sensitive data. Implement data classification and handling policies.",
            VulnerabilityCategory.INJECTION_ATTACK: "Use parameterized queries and input validation. Sanitize all user input.",
            VulnerabilityCategory.AUTHENTICATION: "Implement strong authentication mechanisms. Use multi-factor authentication.",
            VulnerabilityCategory.INPUT_VALIDATION: "Implement comprehensive input validation and output encoding.",
            VulnerabilityCategory.ACCESS_CONTROL: "Implement proper access control mechanisms and least privilege principle.",
            VulnerabilityCategory.CRYPTOGRAPHIC: "Use strong encryption and secure key management. Rotate keys regularly.",
            VulnerabilityCategory.CONFIGURATION: "Review system configuration and remove sensitive path disclosures."
        }
        return remediation_map.get(category, "Review security controls and implement appropriate countermeasures.")
    
    def _get_owasp_references(self, category: VulnerabilityCategory) -> List[str]:
        """Get OWASP references for vulnerability category"""
        owasp_map = {
            VulnerabilityCategory.INJECTION_ATTACK: ["OWASP-A03"],
            VulnerabilityCategory.AUTHENTICATION: ["OWASP-A07"],
            VulnerabilityCategory.ACCESS_CONTROL: ["OWASP-A01"],
            VulnerabilityCategory.INPUT_VALIDATION: ["OWASP-A03"],
            VulnerabilityCategory.DATA_LEAKAGE: ["OWASP-A02"],
            VulnerabilityCategory.CRYPTOGRAPHIC: ["OWASP-A02"]
        }
        return owasp_map.get(category, [])
    
    def _calculate_compliance_score(self, severity_counts: Dict[VulnerabilitySeverity, int], total_events: int) -> float:
        """Calculate compliance score based on findings"""
        if total_events == 0:
            return 100.0
        
        penalty = 0.0
        severity_weights = {
            VulnerabilitySeverity.CRITICAL: 10.0,
            VulnerabilitySeverity.HIGH: 5.0,
            VulnerabilitySeverity.MEDIUM: 2.0,
            VulnerabilitySeverity.LOW: 1.0,
            VulnerabilitySeverity.INFO: 0.1
        }
        
        for severity, count in severity_counts.items():
            penalty += count * severity_weights[severity]
        
        # Normalize penalty and calculate score
        score = 100.0 - (penalty / total_events * 10.0)
        return max(0.0, min(100.0, score))
    
    def get_scan_statistics(self) -> Dict[str, Any]:
        """Get scanner statistics"""
        return {
            "total_rules": len(self.scan_rules),
            "enabled_rules": len([r for r in self.scan_rules if r["enabled"]]),
            "whitelisted_aggregates": len(self.whitelist),
            "rule_categories": len(set(r["category"] for r in self.scan_rules))
        }


async def demonstrate_basic_vulnerability_scanning():
    """Demonstrate basic vulnerability scanning"""
    print("\n=== Basic Vulnerability Scanning ===")
    
    scanner = MockVulnerabilityScanner()
    
    # Create test events with various security issues
    vulnerable_events = [
        {
            "id": str(uuid4()),
            "aggregate_id": "user-profile-001",
            "aggregate_type": "UserProfile",
            "event_type": "ProfileUpdated",
            "data": {
                "user_id": "12345",
                "query": "UPDATE users SET name='Robert'; DROP TABLE users; --'",
                "source_ip": "192.168.1.100"
            },
            "timestamp": datetime.utcnow().isoformat()
        },
        {
            "id": str(uuid4()),
            "aggregate_id": "payment-002",
            "aggregate_type": "Payment",
            "event_type": "PaymentProcessed",
            "data": {
                "credit_card": "4111-1111-1111-1234",
                "ssn": "123-45-6789",
                "amount": 100.00
            },
            "timestamp": datetime.utcnow().isoformat()
        },
        {
            "id": str(uuid4()),
            "aggregate_id": "web-input-003",
            "aggregate_type": "WebForm",
            "event_type": "FormSubmitted",
            "data": {
                "comment": "<script>alert('XSS Attack!')</script>",
                "name": "Test User"
            },
            "timestamp": datetime.utcnow().isoformat()
        },
        {
            "id": str(uuid4()),
            "aggregate_id": "config-004", 
            "aggregate_type": "Configuration",
            "event_type": "ConfigLoaded",
            "data": {
                "config_path": "/etc/passwd",
                "api_key": "sk_live_abcdefghijklmnopqrstuvwxyz1234567890",
                "status": "loaded"
            },
            "timestamp": datetime.utcnow().isoformat()
        },
        {
            "id": str(uuid4()),
            "aggregate_id": "auth-005",
            "aggregate_type": "Authentication",
            "event_type": "LoginAttempt",
            "data": {
                "username": "admin",
                "password": "admin",
                "login_time": datetime.utcnow().isoformat()
            },
            "timestamp": datetime.utcnow().isoformat()
        }
    ]
    
    print(f"Scanning {len(vulnerable_events)} events for security vulnerabilities...")
    
    # Perform vulnerability scan
    scan_result = await scanner.scan_events(vulnerable_events)
    
    print(f"\nScan Results:")
    print(f"  Scan ID: {scan_result['scan_id']}")
    print(f"  Events scanned: {scan_result['events_scanned']}")
    print(f"  Vulnerabilities found: {len(scan_result['vulnerabilities_found'])}")
    print(f"  Scan duration: {scan_result['scan_duration_ms']:.2f}ms")
    print(f"  Compliance score: {scan_result['compliance_score']:.1f}%")
    
    # Show severity breakdown
    print(f"\nSeverity Breakdown:")
    for severity, count in scan_result['severity_counts'].items():
        if count > 0:
            print(f"  {severity}: {count}")
    
    # Show detailed findings
    print(f"\nDetailed Findings:")
    for i, finding in enumerate(scan_result['vulnerabilities_found'], 1):
        print(f"  {i}. {finding['title']} ({finding['severity'].value})")
        print(f"     Event: {finding['event_id']}")
        print(f"     Category: {finding['category'].value}")
        print(f"     Evidence: {finding['evidence']}")
        print(f"     Remediation: {finding['remediation']}")
        if finding['owasp_references']:
            print(f"     OWASP: {', '.join(finding['owasp_references'])}")
        print()
    
    return scanner, scan_result


async def demonstrate_whitelist_management():
    """Demonstrate whitelist management for false positives"""
    print("\n=== Whitelist Management ===")
    
    scanner = MockVulnerabilityScanner()
    
    # Create events including known false positives
    test_events = [
        {
            "id": str(uuid4()),
            "aggregate_id": "test-system-001",
            "aggregate_type": "TestSystem",
            "event_type": "SqlQueryLogged",
            "data": {
                "query": "SELECT * FROM test_table WHERE id = 1 OR status = 'active'",
                "purpose": "legitimate_database_query_for_testing"
            }
        },
        {
            "id": str(uuid4()),
            "aggregate_id": "production-app-002", 
            "aggregate_type": "ProductionApp",
            "event_type": "SqlQueryLogged",
            "data": {
                "query": "SELECT * FROM users WHERE id = 1 OR role = 'admin'",
                "purpose": "suspicious_query_in_production"
            }
        }
    ]
    
    print("Initial scan (without whitelist):")
    initial_result = await scanner.scan_events(test_events)
    print(f"  Vulnerabilities found: {len(initial_result['vulnerabilities_found'])}")
    
    # Add test system to whitelist
    print("\nAdding test-system-001 to whitelist...")
    scanner.add_to_whitelist("test-system-001")
    
    print("Scan after whitelisting:")
    whitelisted_result = await scanner.scan_events(test_events)
    print(f"  Vulnerabilities found: {len(whitelisted_result['vulnerabilities_found'])}")
    
    # Show remaining findings
    for finding in whitelisted_result['vulnerabilities_found']:
        print(f"  Remaining finding: {finding['aggregate_id']} - {finding['title']}")
    
    print("‚úÖ Test system false positives filtered out by whitelist")
    
    return scanner


async def demonstrate_performance_scanning():
    """Demonstrate high-performance vulnerability scanning"""
    print("\n=== Performance Scanning ===")
    
    scanner = MockVulnerabilityScanner()
    
    # Generate large number of test events
    num_events = 1000
    print(f"Generating {num_events} test events for performance testing...")
    
    test_events = []
    for i in range(num_events):
        event = {
            "id": str(uuid4()),
            "aggregate_id": f"perf-test-{i}",
            "aggregate_type": "PerformanceTest",
            "event_type": "TestEvent",
            "data": {
                "sequence": i,
                "payload": f"test data {i}",
                "status": "processing"
            },
            "timestamp": datetime.utcnow().isoformat()
        }
        test_events.append(event)
    
    # Add some vulnerable events
    for i in range(0, num_events, 100):  # Every 100th event has a vulnerability
        test_events[i]["data"]["potential_issue"] = "SELECT * FROM sensitive_table"
    
    print(f"Running performance scan on {num_events} events...")
    
    # Perform performance scan
    start_time = datetime.utcnow()
    result = await scanner.scan_events(test_events)
    end_time = datetime.utcnow()
    
    total_time = (end_time - start_time).total_seconds()
    events_per_second = num_events / total_time
    
    print(f"\nPerformance Results:")
    print(f"  Events scanned: {result['events_scanned']}")
    print(f"  Total scan time: {total_time:.3f} seconds")
    print(f"  Scanning rate: {events_per_second:.0f} events/second")
    print(f"  Vulnerabilities found: {len(result['vulnerabilities_found'])}")
    print(f"  Compliance score: {result['compliance_score']:.1f}%")
    
    return result


async def demonstrate_security_reporting():
    """Demonstrate comprehensive security reporting"""
    print("\n=== Security Reporting ===")
    
    scanner = MockVulnerabilityScanner()
    
    # Create events representing various security scenarios
    security_events = []
    
    # Critical vulnerabilities
    for i in range(3):
        security_events.append({
            "id": str(uuid4()),
            "aggregate_id": f"critical-{i}",
            "aggregate_type": "CriticalSystem",
            "event_type": "DataExposure",
            "data": {"ssn": f"123-45-678{i}", "sensitive": True}
        })
    
    # High severity vulnerabilities  
    for i in range(5):
        security_events.append({
            "id": str(uuid4()),
            "aggregate_id": f"high-risk-{i}",
            "aggregate_type": "WebApplication",
            "event_type": "UserInput",
            "data": {"input": f"<script>alert('attack{i}')</script>"}
        })
    
    # Medium severity vulnerabilities
    for i in range(10):
        security_events.append({
            "id": str(uuid4()),
            "aggregate_id": f"medium-risk-{i}",
            "aggregate_type": "AuthSystem", 
            "event_type": "LoginAttempt",
            "data": {"username": "admin", "password": "password"}
        })
    
    # Clean events
    for i in range(100):
        security_events.append({
            "id": str(uuid4()),
            "aggregate_id": f"clean-{i}",
            "aggregate_type": "CleanSystem",
            "event_type": "NormalOperation",
            "data": {"operation": "legitimate_business_logic", "user": f"user{i}"}
        })
    
    print(f"Performing comprehensive security scan on {len(security_events)} events...")
    
    # Perform comprehensive scan
    comprehensive_result = await scanner.scan_events(security_events)
    
    # Generate security report
    print(f"\nüìä COMPREHENSIVE SECURITY REPORT")
    print(f"=" * 50)
    print(f"Scan ID: {comprehensive_result['scan_id']}")
    print(f"Scan Date: {comprehensive_result['scan_timestamp'].strftime('%Y-%m-%d %H:%M:%S UTC')}")
    print(f"Events Analyzed: {comprehensive_result['events_scanned']:,}")
    print(f"Scan Duration: {comprehensive_result['scan_duration_ms']:.0f}ms")
    print(f"Overall Compliance Score: {comprehensive_result['compliance_score']:.1f}%")
    
    # Risk assessment
    total_findings = len(comprehensive_result['vulnerabilities_found'])
    print(f"\nüîç VULNERABILITY SUMMARY")
    print(f"Total Findings: {total_findings}")
    
    severity_counts = comprehensive_result['severity_counts']
    for severity in ['Critical', 'High', 'Medium', 'Low', 'Info']:
        count = severity_counts.get(severity, 0)
        if count > 0:
            percentage = (count / total_findings * 100) if total_findings > 0 else 0
            print(f"  {severity}: {count} ({percentage:.1f}%)")
    
    # Category breakdown
    print(f"\nüìÇ VULNERABILITY CATEGORIES")
    category_counts = comprehensive_result['category_counts']
    for category, count in category_counts.items():
        if count > 0:
            print(f"  {category}: {count}")
    
    # Risk score calculation
    risk_score = 100 - comprehensive_result['compliance_score']
    risk_level = "LOW"
    if risk_score > 70:
        risk_level = "CRITICAL"
    elif risk_score > 40:
        risk_level = "HIGH"
    elif risk_score > 15:
        risk_level = "MEDIUM"
    
    print(f"\n‚ö†Ô∏è  RISK ASSESSMENT")
    print(f"Risk Score: {risk_score:.1f}/100")
    print(f"Risk Level: {risk_level}")
    
    # Recommendations
    print(f"\nüí° RECOMMENDATIONS")
    if severity_counts.get('Critical', 0) > 0:
        print(f"  üö® IMMEDIATE ACTION REQUIRED: {severity_counts['Critical']} critical vulnerabilities")
    if severity_counts.get('High', 0) > 0:
        print(f"  üî• HIGH PRIORITY: Address {severity_counts['High']} high-severity issues")
    if severity_counts.get('Medium', 0) > 0:
        print(f"  ‚ö° MEDIUM PRIORITY: Review {severity_counts['Medium']} medium-severity issues")
    
    print(f"  üìà Compliance target: Achieve >95% compliance score")
    print(f"  üîÑ Recommended scan frequency: Daily for critical systems")
    
    return comprehensive_result


async def demonstrate_compliance_integration():
    """Demonstrate integration with compliance frameworks"""
    print("\n=== Compliance Framework Integration ===")
    
    scanner = MockVulnerabilityScanner()
    
    # Create events representing different compliance scenarios
    compliance_events = [
        # PCI DSS - Payment card data
        {
            "id": str(uuid4()),
            "aggregate_id": "payment-pci-001",
            "aggregate_type": "PaymentProcessor",
            "event_type": "CardDataProcessed",
            "data": {
                "card_number": "4111111111111111",  # Test card number (would trigger PII detection)
                "cardholder_name": "John Doe",
                "compliance_scope": "PCI_DSS"
            }
        },
        # HIPAA - Health information
        {
            "id": str(uuid4()),
            "aggregate_id": "medical-hipaa-001",
            "aggregate_type": "MedicalRecord",
            "event_type": "PatientDataAccessed",
            "data": {
                "patient_ssn": "123-45-6789",
                "medical_record": "Patient diagnosis and treatment",
                "compliance_scope": "HIPAA"
            }
        },
        # SOX - Financial reporting
        {
            "id": str(uuid4()),
            "aggregate_id": "finance-sox-001",
            "aggregate_type": "FinancialReport",
            "event_type": "ReportGenerated",
            "data": {
                "sql_query": "SELECT revenue FROM financial_data WHERE quarter = 'Q4'",
                "compliance_scope": "SOX"
            }
        }
    ]
    
    print("Scanning compliance-sensitive events...")
    compliance_result = await scanner.scan_events(compliance_events)
    
    # Map findings to compliance frameworks
    compliance_mapping = {
        VulnerabilityCategory.DATA_LEAKAGE: ["PCI_DSS", "HIPAA", "GDPR"],
        VulnerabilityCategory.INJECTION_ATTACK: ["SOX", "PCI_DSS"],
        VulnerabilityCategory.ACCESS_CONTROL: ["HIPAA", "SOX", "PCI_DSS"],
        VulnerabilityCategory.AUTHENTICATION: ["All frameworks"],
        VulnerabilityCategory.CRYPTOGRAPHIC: ["PCI_DSS", "HIPAA"]
    }
    
    print(f"\nüèõÔ∏è  COMPLIANCE IMPACT ANALYSIS")
    print(f"=" * 40)
    
    framework_impacts = {}
    for finding in compliance_result['vulnerabilities_found']:
        category = finding['category']
        affected_frameworks = compliance_mapping.get(category, [])
        
        for framework in affected_frameworks:
            if framework not in framework_impacts:
                framework_impacts[framework] = []
            framework_impacts[framework].append(finding)
    
    for framework, findings in framework_impacts.items():
        print(f"\n{framework} Compliance:")
        print(f"  Affected findings: {len(findings)}")
        severity_distribution = {}
        for finding in findings:
            severity = finding['severity'].value
            severity_distribution[severity] = severity_distribution.get(severity, 0) + 1
        
        for severity, count in severity_distribution.items():
            print(f"    {severity}: {count}")
        
        # Compliance status
        critical_count = severity_distribution.get('Critical', 0)
        high_count = severity_distribution.get('High', 0)
        
        if critical_count > 0:
            status = "‚ùå NON-COMPLIANT (Critical issues)"
        elif high_count > 0:
            status = "‚ö†Ô∏è  AT RISK (High severity issues)"
        else:
            status = "‚úÖ COMPLIANT"
        
        print(f"  Status: {status}")
    
    return compliance_result


async def main():
    """Run all vulnerability scanning demonstrations"""
    print("üîç Eventuali Vulnerability Scanning - Example 28")
    print("=" * 60)
    print("\nThis example demonstrates comprehensive security vulnerability scanning.")
    print("Features include pattern detection, severity classification, compliance mapping,")
    print("and automated security assessment with remediation guidance.")
    
    try:
        # Run all demonstrations
        scanner, basic_result = await demonstrate_basic_vulnerability_scanning()
        await demonstrate_whitelist_management()
        await demonstrate_performance_scanning()
        await demonstrate_security_reporting()
        await demonstrate_compliance_integration()
        
        # Show scanner statistics
        stats = scanner.get_scan_statistics()
        print(f"\nüìà SCANNER STATISTICS")
        print(f"=" * 30)
        print(f"Total scan rules: {stats['total_rules']}")
        print(f"Enabled rules: {stats['enabled_rules']}")
        print(f"Whitelisted aggregates: {stats['whitelisted_aggregates']}")
        print(f"Rule categories: {stats['rule_categories']}")
        
        print("\n" + "=" * 60)
        print("‚úÖ Vulnerability Scanning Demonstrations Completed Successfully!")
        print("\nüìã Key Features Demonstrated:")
        print("   ‚Ä¢ Pattern-based vulnerability detection")
        print("   ‚Ä¢ Multi-severity classification system")
        print("   ‚Ä¢ OWASP Top 10 coverage")
        print("   ‚Ä¢ High-performance scanning engine")
        print("   ‚Ä¢ Compliance framework integration")
        print("   ‚Ä¢ False positive management")
        print("\nüîí Security Benefits:")
        print("   ‚Ä¢ Proactive threat detection")
        print("   ‚Ä¢ Automated compliance monitoring")
        print("   ‚Ä¢ Real-time security assessment")
        print("   ‚Ä¢ Comprehensive audit trails")
        print("   ‚Ä¢ Remediation guidance")
        
    except Exception as e:
        print(f"\n‚ùå Error during demonstration: {e}")
        raise


if __name__ == "__main__":
    asyncio.run(main())